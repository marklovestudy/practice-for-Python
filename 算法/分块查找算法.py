'''
分块查找算法：
    就是把一个大的线性数据分解成若干块，每个块中的结点可以任意存放，但块与块之间必须排序。
    与此同时，还要建立一个索引表，把每块中的最大值作为索引表的索引值，此索引表需要按块的顺序
    存放到一个辅助数组中。查找时，首先在索引表中进行查找，确定要找的结点所在的块。由于索引表
    是排序的，因此，对索引表的查找可以采用顺序查找算法或二分查找算法；然后在相应的块中采用顺序查找。

如：有这样的一列数据23，43，56，78，97，100，120，135，147，150，155,想要查找的数据是150.
利用分块查找步骤如下：
    步骤1：将数据按长度为4，分为三块，
    第一块：23，43，56，78，第二块：97，100，120，135，第三块：147，150，155
    步骤2：选取各块中的最大关键字，构成一个索引表：
        78      135     155         #分块中的最大值
        3       7       10          #分块中的最大值所对应的索引号
    步骤3：接下来判断150在哪块内，可以采用顺序查找或折半查找，即索引表的中间值135与目标值150比较。
    步骤4：从索引表的中间位置数据可以看出135小于150，因此目标数据150在135的下一块内。将数据定位在
    第三块内，此时将第三块内的数据取出，进行顺序比较。
    步骤5：通过顺序查找第三块的内容，终于在第9个位置找到了目标数，此时查找结束。

    注:当数据很多很大时，可以采用折半查找算法对索引表进行查找，提高效率，分块查找的效率在顺序查找和折半查找之间。
'''
def search(l,key):
    n = len(l)
    i,j = 0,n-1
    b = -1
    while i<=j:
        m = (i+j)//2
        if key == l[m]:
            return m
        elif key > l[m]:
            i = m + 1
        else:
            j = m - 1       #因为取整的原因，会让m=2时，j取1，(i+j)//2=(0+1)//2=0,遗漏索引为1时的值。
    return False

def block(l,c,n):
    length=len(l)
    b_length=length//c
    if b_length * c != length:
        b_length += 1
    for b_i in range(b_length):
        b_data=[]
        for i in range(c):
            if b_i * c + i >= length:
                break
            b_data.append(l[b_i*c+i])
        result = search(b_data,n)
        if result != False:
            return b_i * c + result
    return False

data = [23,43,56,78,97,100,120,135,147,150,155]
result=block(data,4,100)
print(result)