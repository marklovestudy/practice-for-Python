'''
对分查找的概念
    对分查找又称二分查找，是一种高效的查找方法。对分查找的前提是，被查找的数据序列是有序的(升序，降序)

对分查找的基本思想
    对分查找的基本思想是在有序的数列中，首先将要查找的数据与有序数列内处于中间位置的数据进行比较，如果
    两者相等，则查找成功；否则就根据数据的有序性，再确定该数据的范围应该在数列的前半部分还是后半部分；
    在新确定的缩少范围内，继续按上述方法进行查找，直到找到要找的数据，即查找成功，如果要查找的数据不存
    在，即查找不成功。

对分查找的处理过程
    若key为查找键，数组a存放n个已按升序排序的元素。在使用对分查找时，把查找范围[i,j]的中间位置上的数据
    a[m]与查找键key进行比较，结果必然是如下三种情况之一：
        1若key<a[m],查找键小于中点a[m]处的数据。由a中的数据的递增性，可以确定：在(m,j)内不可能存在
        值为key的数据，必须在新的范围(i,m-1)中继续查找；
        2key=a[m],找到了需要的数据；
        3key>a[m]，由与1相同的理由，必须在新的范围(m+1,j)中继续查找。
    这样，除了出现情况2，在通过一次比较后，新的查找范围将不超过上次查找范围的一半。
    中间位置数据a[m]的下标m的计算方法：m=(i+j)//2,或m=int((i+j)/2)

对分查找的程序实现
    1由于比较次数难以确定，所以用while语句来实现循环；
    2在while循环体中用if语句来判断查找是否成功；
    3若查找成功则输出查找结果，并结束循环(break)；
    4若查找不成功，则判断查找键在数组的左关区间还是右半区间，从而缩小范围。

我们假设一个列表l = [12,17,23,25,26,35,47,68,76,88,96]
查找key=25
l = [12,17,23,25,26,35,47,68,76,88,96]
key=25
n = len(l)
i,j = 0,n-1
b = -1
while i<j:
    m = (i+j)//2
    if key == l[m]:
        b = m
        break
    elif key > l[m]:
        i = m + 1
    else:
        j = m - 1
if b == -1:
    print('没有找到')
else:
    print('找到%s在列表的%s的位置'%(key,b))

对分查找的查找次数的估算
    对元素规模为n的列表进行对分查找时，无论是否找到，至多进行了log2n + 1(log2n + 1表示大于等于log2n的最小整数)
    次查找就能得到结果，而使用顺序查找，在最坏的情况下(查找键在最后一个或不在列表内)，需要进行n次查找，最好的情况是一次查找
    (查找的键在第一个)，平均查找(n+1)/2数次。所以对分查找效率较高。
'''
l = [12,17,23,25,26,35,47,68,76,88,96]
key=25
n = len(l)
i,j = 0,n-1
b = -1
while i<j:
    m = (i+j)//2
    if key == l[m]:
        b = m
        break
    elif key > l[m]:
        i = m + 1
    else:
        j = m - 1       #因为取整的原因，会让m=2时，j取1，(i+j)//2=(0+1)//2=0,遗漏索引为1时的值。
if b == -1:
    print('没有找到')
else:
    print('找到%s在列表的%s的位置'%(key,b))
